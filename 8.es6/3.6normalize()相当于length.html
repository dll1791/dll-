<!DOCTYPE html>
<!-- 
 许多欧洲语言有语调符号和重音符号。为了表示它们，
 Unicode提供了两种方法。一种是直接提供带重音符号的字符，
 比如Ǒ（\u01D1）。另一种是提 供合成符号（combining character），
 即原字符与重音符号的合成，两个字符合成一个字符，
 比如O（\u004F）和ˇ（\u030C）合 成Ǒ（\u004F\u030C）。
 这两种表示方法，在视觉和语义上都等价，但是JavaScript不能识别。
 
 '\u01D1'==='\u004F\u030C' //false  俩个长度不一样一个为1一个为2所以不能识别
 
 ES6提供字符串实例的normalize()方法，用来将字符的不同表示方法统
 一为同样的形式，这称为Unicode正规化。
'\u01D1'.normalize() === '\u004F\u030C'.normalize() // true
 
 normalize方法可以接受一个参数来指定normalize的方式，参数的四个可选值如下。
	  NFC，默认参数，表示“标准等价合成”，返回多个简单字符的合成字符。
	  所谓“标准等价”指的是视 觉和语义上的等价。
	   NFD，表示“标准等价分解”，即在标准等价的前提下，
	   返回合成字符分解的多个简单字符。 
	   NFKC，表示“兼容等价合成”，返回合成字符。
	   所谓“兼容等价”指的是语义上存在等价，但视觉 上不等价，
	   比如“囍”和“喜喜”。（这只是用来举例，normalize方法不能识别中文。）
	 NFKD，表示“兼容等价分解”，即在兼容等价的前提下，
	 返回合成字符分解的多个简单字符。
	 
	 '\u004F\u030C'.normalize('NFC').length // 1 
	 '\u004F\u030C'.normalize('NFD').length // 2
	 不过，normalize方法目前不能识别三个或三个以上字符的合成。
	 这种情况下，还是只能使用正则表达式，通过Unicode编号区间判断。
 -->
<html>
	<head>
		<meta charset="utf-8">
		<title></title>
	</head>
	<body>
		<script type="text/javascript">
			var a="\u01D1";
			var b="\u004f\u030c";
			console.log(a);
			console.log(b);
		</script>
	</body>
</html>
